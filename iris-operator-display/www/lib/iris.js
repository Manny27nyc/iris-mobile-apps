/*global setImmediate: false, setTimeout: false, console: false */
(function () {

	var iris = {};

	// global on the server, window in the browser
	var root, previous_iris;

	root = this;
	if (root != null) {
	  previous_iris = root.iris;
	}

	iris.noConflict = function () {
		root.iris = previous_iris;
		return iris;
	};

	//// exported iris module functions ////

	//// nextTick implementation with browser-compatible fallback ////
	if (typeof process === 'undefined' || !(process.nextTick)) {
		if (typeof setImmediate === 'function') {
			iris.nextTick = function (fn) {
				// not a direct alias for IE10 compatibility
				setImmediate(fn);
			};
			iris.setImmediate = iris.nextTick;
		}
		else {
			iris.nextTick = function (fn) {
				setTimeout(fn, 0);
			};
			iris.setImmediate = iris.nextTick;
		}
	}
	else {
		iris.nextTick = process.nextTick;
		if (typeof setImmediate !== 'undefined') {
			iris.setImmediate = setImmediate;
		}
		else {
			iris.setImmediate = iris.nextTick;
		}
	}
	
	//
	// Вспомогательный код (http://javascript.ru/tutorial/object/inheritance):
	//

	iris.extendPrototype = function(Child, Parent) {
		var F = function() { };
		F.prototype = Parent.prototype;
		Child.prototype = new F();
		Child.prototype.constructor = Child;
		Child.superclass = Parent.prototype;
	};
	
	// копирует все свойства из src в dst,
	// включая те, что в цепочке прототипов src до Object
	function mixin(dst, src){
		// tobj - вспомогательный объект для фильтрации свойств,
		// которые есть у объекта Object и его прототипа
		var tobj = {};
		for(var x in src){
			// копируем в dst свойства src, кроме тех, которые унаследованы от Object
			if((typeof tobj[x] === "undefined") || (tobj[x] != src[x])){
				dst[x] = src[x];
			}
		}
		// В IE пользовательский метод toString отсутствует в for..in
		if("undefined" !== typeof document && document.all && !document.isOpera){
			var p = src.toString;
			if(typeof p === "function" && p != dst.toString && p != tobj.toString &&
			 p != "\nfunction toString() {\n    [native code]\n}\n"){
				dst.toString = src.toString;
			}
		}
	}
	
	/**
	 * Расширяет объект Src свойствами второго аргумента
	 * @param {function} Src Объект для расширения
	 * @param {object} Ext Дополнительные свойства
	 * @returns {function} Расширенный объект Parent.
	 */
	iris.objectExtend = function(Src, Ext) {
		mixin(Src, Ext);
		return Src;
	};

	// https://gist.github.com/gordonbrander/2230317
	// 
	// Generate unique IDs for use as pseudo-private/protected names.
	// Similar in concept to
	// <http://wiki.ecmascript.org/doku.php?id=strawman:names>.
	//
	// The goals of this function are twofold:
	// 
	// * Provide a way to generate a string guaranteed to be unique when compared
	//   to other strings generated by this function.
	// * Make the string complex enough that it is highly unlikely to be
	//   accidentally duplicated by hand (this is key if you're using `ID`
	//   as a private/protected name on an object).
	//
	// Use:
	//
	//     var privateName = ID();
	//     var o = { 'public': 'foo' };
	//     o[privateName] = 'bar';
	function _generateUniqueId() {
		// Math.random should be unique because of its seeding algorithm.
		// Convert it to base 36 (numbers + letters), and grab the first 9 characters
		// after the decimal.
		return Math.random().toString(36).substr(2, 9);
	};
	
	// Используется при восстановлении объектов на другой стороне
	// при отсутствии в объекте iris ссылок на динамически сформированные имена
	// функций-конструкторов, типа __Iris_Internal_ojz567o48
	iris.__iris_dynamic_constructor_name = "__iris_dynamic_constructor";
	function __iris_dynamic_constructor(){}
	iris.__iris_dynamic_constructor = __iris_dynamic_constructor;
	
	/**
	 * Создаёт объект типа Parent и добавляет в него свойства второго аргумента
	 * @param {function} Parent Функция, определяющая тип конечного объекта
	 * @param {object} Ext Дополнительные свойства
	 * @returns {function} Расширенный объект типа Parent.
	 */
	iris.extend = function(Parent, Ext) {
		var objName = _generateUniqueId();
		eval("function __Iris_Internal_" + objName + "() {} var F = iris.__Iris_Internal_" + objName + "=__Iris_Internal_" + objName + ";");
		var Constructor = Parent;
		var isObject = typeof Parent === "object";
		if (isObject) {
			Constructor = Parent.constructor;
		}
		iris.extendPrototype(F, Constructor);
		mixin(F.prototype, Ext);
		// подсказка для Hydrate при восстановлении объектов из json
		if (!isObject) {
			Parent.prototype.constructor_name = iris.__iris_dynamic_constructor_name;
		}
		return new F;
	};
	
	/**
	 * Преобразует цепочку вложенных прототипов во вложенные объекты,
	 * чтобы их можно было сериаизовать средствами Hydrate
	 * @param {object} o
	 */
	iris._prepareForHydrate = function(o) {
		if (!o) {
			return;
		}
		if (o.hasOwnProperty("__iris_proto_object")) {
			// уже подготовлен
			return;
		}
		for(var i in o) {
			if (o.hasOwnProperty(i) && 
				null !== o[i] && 
				"object" === typeof o[i]
			) {
				iris._prepareForHydrate(o[i]);
			}
		}
		if (o.__proto__.constructor === Object) {
			return;
		}
		o.__iris_proto_object = o.__proto__;
		iris._prepareForHydrate(o.__proto__);
	};

	/**
	 * Очищает цепочку вложенных прототипов после применения _prepareForHydrate
	 * @param {object} o
	 */
	iris._clearAfterHydrate = function(o) {
		if (!o) {
			return;
		}
		for(var i in o) {
			if (o.hasOwnProperty(i) && "object" === typeof o[i]) {
				iris._clearAfterHydrate(o[i]);
			}
		}
		if (o.__proto__.constructor === Object) {
			return;
		}
		delete o.__iris_proto_object;
		iris._clearAfterHydrate(o.__proto__);
	};

	/**
	 * Подготавливает JSON для передачи в Hydrate.parse
	 * @param {String} s JSON из фунуции Hydrate.stringify
	 * @returns {String} JSON для передачи в Hydrate.parse
	 */
	iris._clearJSONAfterHydrate = function(s) {
		if ("null" === s) {
			return s;
		}
		var obj = JSON.parse(s);
		function replacer(o) {
			if (typeof o !== "object") {
				return;
			}
			for(var i in o) {
				if (o.hasOwnProperty(i)) {
					if ("__hydrate_cons" === i &&
						-1 !== o[i].indexOf("__Iris_Internal_")
					) {
						o[i] = iris.__iris_dynamic_constructor_name;
					} else {
						replacer(o[i]);
					}
				}
			}
		}
		replacer(obj);
		return JSON.stringify(obj);
	};

	/**
	 * Из восстановленного функцией Hydrate.parse объекта воссоздаёт
	 * объект корректной структуры, со всеми прототипами и свойствами
	 * @param {object} obj Восстановленный функцией Hydrate.parse объект
	 * @returns {object} Воссозданный объект корректной структуры,
	 * со всеми прототипами и свойствами
	 */
	iris._restoreUnhydratedTypes = function(obj) {
		if (!obj) {
			return obj;
		}
		if (!obj.hasOwnProperty("__iris_proto_object")) {
			for(var i in obj) {
				if (obj.hasOwnProperty(i)) {
					obj[i] = iris._restoreUnhydratedTypes(obj[i]);
				}
			}
			return obj;
		}
		if (!obj.__iris_proto_object.hasOwnProperty("__iris_proto_object")) {
			// Добрались до самого первого настоящего прототипа
			delete obj.constructor_name;
			delete obj.__iris_proto_object.constructor_name;
			return obj.__iris_proto_object.constructor;
		}
		var Parent = iris._restoreUnhydratedTypes(obj.__iris_proto_object);
		var Ext = {};
		for (var i in obj.__iris_proto_object) {
			if ("constructor_name" !== i && "__iris_proto_object" !== i &&
				obj.__iris_proto_object.hasOwnProperty(i) &&
				("undefined" === typeof Parent[i] || Parent[i] !== obj.__iris_proto_object[i])
			) {
				Ext[i] = obj.__iris_proto_object[i];
			}
		}
		for (var i in obj) {
			if ("__iris_proto_object" !== i && obj.hasOwnProperty(i)) {
				Ext[i] = iris._restoreUnhydratedTypes(obj[i]);
			}
		}
		return iris.extend(Parent, Ext);
	};
	
	//
	// Подготовка объекта к отправке по сети:
	// iris._prepareForHydrate(m2)
	// m2h = hydrate.stringify(m2)
	// m2hc = iris._clearJSONAfterHydrate(m2h)
	// iris._clearAfterHydrate(m2)
	// 
	// Восстановление переданного по сети объекта:
	// m2huh = hydrate.parse(m2hc)
	// m2huhr = iris._restoreUnhydratedTypes(m2huh)
	//

	/**
	 * Создаёт JSON-представление объекта для передачи по сети
	 * @param {object} obj Объект
	 * @param {Hydrate} hydrate Объект библиотеки HydrateJS
	 * Должен быть проинициализирован с context resolver iris:
	 * var resolver = iris.makeHydrateContextResolver(Hydrate);
	 * var hydrate = new Hydrate(resolver);
	 * @returns {string} Specially prepared JSON representation of the obj
	 */
	iris.hydrateObject = function (obj, hydrate) {
		iris._prepareForHydrate(obj);
		var jsonData = hydrate.stringify(obj);
		iris._clearAfterHydrate(obj);
		var clearedJsonData = iris._clearJSONAfterHydrate(jsonData);
		return clearedJsonData;
	};

	/**
	 * Восстановление переданного по сети объекта
	 * @param {string} clearedJsonData Specially prepared JSON representation of some obj
	 * @param {Hydrate} hydrate Объект библиотеки HydrateJS.
	 * Должен быть проинициализирован с context resolver iris:
	 * var resolver = iris.makeHydrateContextResolver(Hydrate);
	 * var hydrate = new Hydrate(resolver);
	 * @returns {object} Восстановленный объект
	 */
	iris.dehydrateObject = function (clearedJsonData, hydrate) {
		var obj = hydrate.parse(clearedJsonData);
//		debugger;
		var objRestoredTypes = iris._restoreUnhydratedTypes(obj);
//		var objRestoredTypes = iris._restoreUnhydratedTypes(obj["1"].qa.questionGroup.mo);
		return objRestoredTypes;
	};
	
	/**
	 * Создаёт resolver пригодный для использования с объектами iris
	 * @param {Hydrate} Hydrate - Конструктор библиотеки HydrateJS
	 * @returns {Hydrate.MultiResolver} Resover, пригодный для использования с
	 * объектами iris
	 */
	iris.makeHydrateContextResolver = function(Hydrate) {
		return new Hydrate.MultiResolver([
			new Hydrate.ContextResolver(iris)
			, new Hydrate.ContextResolver(iris.qa)
		]);
	};

	//
	// Базовые объекты сущностей Базы Знаний ИРИС
	//
	
	function Design() {}
	Design.prototype.id = null;
	Design.prototype.name = "";
	Design.prototype.code = "";
	Design.prototype.isSystem = false;
	Design.prototype.workplaceTypeId = null;
	iris.Design = Design;

	/**
	 * type: room_display
	 */
	function RoomDisplayDesign() {
		RoomDisplayDesign.superclass.constructor.call(this);
	}
	iris.extendPrototype(RoomDisplayDesign, Design);
	RoomDisplayDesign.prototype.workplaceTypeId = 1;
	iris.RoomDisplayDesign = RoomDisplayDesign;

	/**
	 * type: operator_display
	 */
	function OperatorDisplayDesign() {
		OperatorDisplayDesign.superclass.constructor.call(this);
	}
	iris.extendPrototype(OperatorDisplayDesign, Design);
	OperatorDisplayDesign.prototype.workplaceTypeId = 2;
	iris.OperatorDisplayDesign = OperatorDisplayDesign;

	/**
	 * type: ticket_template
	 */
	function TicketTemplateDesign() {
		TicketTemplateDesign.superclass.constructor.call(this);
	}
	iris.extendPrototype(TicketTemplateDesign, Design);
	TicketTemplateDesign.prototype.workplaceTypeId = 3;
	iris.TicketTemplateDesign = TicketTemplateDesign;

	/**
	 * type: qa_terminal
	 */
	function StaticDisplayDesign() {
		StaticDisplayDesign.superclass.constructor.call(this);
	}
	iris.extendPrototype(StaticDisplayDesign, Design);
	StaticDisplayDesign.prototype.workplaceTypeId = 6;
	iris.StaticDisplayDesign = StaticDisplayDesign;

	function Display() {}
	Display.prototype.id = null;
	Display.prototype.desc = "";
	Display.prototype.audioEnabled = true;
	Display.prototype.creepingLine = "";
	Display.prototype.creepingLine2 = "";
	Display.prototype.doubleColumn = false;
	/**
	 * @type {Design}
	 */
	Display.prototype.design = null;
	// room_display
	Display.prototype.workplaceTypeId = 1;
	iris.Display = Display;

	iris.qa = {};

	function Answer() {}
	Answer.prototype.id = null;
	Answer.prototype.title = "";
	/**
	 * Опросник, ассоциированный с этим ответом
	 * @type {Question[]}
	 */
	Answer.prototype.qa = null;
	iris.qa.Answer = Answer;

	function Question() {}
	Question.prototype.id = null;
	Question.prototype.title = "";
	/**
	 * @type {Answer[]}
	 */
	Question.prototype.answers = {};
	iris.qa.Question = Question;

	function Service() {}
	Service.prototype.id = null;
	Service.prototype.name = "";
	Service.prototype.shortDesc = "";
	Service.prototype.longDesc = "";
	/**
	 * @type {QA}
	 */
	Service.prototype.qa = null;
	iris.Service = Service;
	
	function Office() {}
	Office.prototype.id = null;
	Office.prototype.secretCode = null;
	Office.prototype.name = "";
	Office.prototype.shortDesc = "";
	Office.prototype.longDesc = "";
	Office.prototype.ticketTemplate = "";
	iris.Office = Office;
	
	function Department() {}
	Department.prototype.id = null;
	Department.prototype.name = "";
	Department.prototype.shortDesc = "";
	Department.prototype.longDesc = "";
	Department.prototype.ticketAddText = "";
	Department.prototype.ticketTemplate = "";
	/**
	 * @type {Office}
	 */
	Department.prototype.office = null;
	/**
	 * @type {Operator[]}
	 */
	Department.prototype.operators = [];
	iris.Department = Department;
	
	function Operator() {}
	Operator.prototype.id = null;
	Operator.prototype.hrIdentifier = "";
	Operator.prototype.isEnabled = true;
	Operator.prototype.hrId = 1;
	/**
	 * @type {Department}
	 */
	Operator.prototype.department = null;
	/**
	 * @type {StaticDisplayDesign}
	 */
	Operator.prototype.qaTerminalDesign = null;
	/**
	 * @type {OperatorDisplayDesign}
	 */
	Operator.prototype.operatorDisplayDesign = null;
	// operator_display
	Operator.prototype.displayWorkplaceTypeId = 2;
	Operator.prototype.qaWorkplaceTypeId = 6;
	iris.Operator = Operator;
	
	//
	// -------------------------------------------------------------------------
	//

	// AMD / RequireJS
	if (typeof define !== 'undefined' && define.amd) {
		define([], function () {
			return iris;
		});
	}
	// Node.js
	else if (typeof module !== 'undefined' && module.exports) {
		module.exports = iris;
	}
	// included directly via <script> tag
	else {
		root.iris = iris;
	}

}());
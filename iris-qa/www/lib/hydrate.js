// Generated by CoffeeScript 1.4.0
(function() {
  var scope,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  scope = this;

  (function(definition) {
    if (typeof bootstrap === "function") {
      return bootstrap("hydrate", definition);
    } else if (typeof exports === "object") {
      return module.exports = definition();
    } else if (typeof define === "function" && define.amd) {
      return define(definition);
    } else if (typeof ses !== "undefined") {
      if (!ses.ok()) {

      } else {
        return ses.makeHydrate = definition;
      }
    } else {
      return scope.Hydrate = definition();
    }
  })(function() {
    var ContextResolver, Hydrate, MultiResolver, Resolver, Util;
    Util = {
      d2h: function(d) {
        return d.toString(16);
      },
      h2d: function(h) {
        return parseInt(h, 16);
      },
      supportsProto: {}.__proto__ != null,
      supportsFunctionNames: typeof (function() {}).name === "string"
    };
    Util.functionName = Util.supportsFunctionNames ? function(func) {
      return func.name;
    } : function(func) {
      var _ref;
      return (_ref = func.toString().match(/function ([^(]*)/)) != null ? _ref[1] : void 0;
    };
    Util.isArray = Array.isArray ? Array.isArray : function(arr) {
      return Object.prototype.toString.call(arr) === "[object Array]";
    };
    Hydrate = (function() {

      Hydrate.NonPrototypeFunctionError = (function(_super) {

        __extends(NonPrototypeFunctionError, _super);

        function NonPrototypeFunctionError(object, name) {
          this.object = object;
          this.name = name;
          this.message = "Couldn't serialize object; had non-prototype function '" + this.name + "'";
        }

        return NonPrototypeFunctionError;

      })(Error);

      Hydrate.PrototypeNotFoundError = (function(_super) {

        __extends(PrototypeNotFoundError, _super);

        function PrototypeNotFoundError(object, cons_id) {
          this.object = object;
          this.cons_id = cons_id;
          this.message = "Prototype not found for object; looked for " + this.cons_id;
        }

        return PrototypeNotFoundError;

      })(Error);

      Hydrate.AnonymousConstructorError = (function(_super) {

        __extends(AnonymousConstructorError, _super);

        function AnonymousConstructorError(object) {
          this.object = object;
          this.message = "Couldn't resolve constructor name; seems it has an anonymous constructor and object's prototype has no #constructor_name property to provide hints";
        }

        return AnonymousConstructorError;

      })(Error);

      Hydrate.VersionInstancePropertyError = (function(_super) {

        __extends(VersionInstancePropertyError, _super);

        function VersionInstancePropertyError(object) {
          this.object = object;
          this.message = "Objects can't have versions on the instances; can only be on the prototype";
        }

        return VersionInstancePropertyError;

      })(Error);

      function Hydrate(resolver) {
        this.resolver = resolver != null ? resolver : null;
        if (!(this.resolver != null)) {
          if (typeof window === "undefined") {
            throw new Error("A context-resolver is required in non-browser environments");
          }
          this.resolver = new ContextResolver(scope);
        }
        this.errorHandler = function(e) {
          throw e;
        };
        this.migrations = {};
      }

      Hydrate.prototype.stringify = function(input) {
        var arr, i, result;
        this.processed_inputs = [];
        this.counter = 0;
        result = (function() {
          var _i, _len;
          switch (typeof input) {
            case "number":
            case "string":
              return JSON.stringify(input);
            case "function":
              throw new Error("can't serialize functions");
              break;
            default:
              if (Util.isArray(input)) {
                arr = [];
                for (_i = 0, _len = input.length; _i < _len; _i++) {
                  i = input[_i];
                  arr.push(this.analyze(i));
                }
                return JSON.stringify(arr);
              } else {
                return JSON.stringify(this.analyze(input));
              }
          }
        }).call(this);
        this.cleanAfterStringify();
        return result;
      };

      Hydrate.prototype.cleanAfterStringify = function() {
        var input, _i, _len, _ref;
        _ref = this.processed_inputs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          if (input) {
            delete input.__hydrate_id;
            delete input.version;
          }
        }
        return true;
      };

      Hydrate.prototype.analyze = function(input, name) {
        var cons, i, k, output, v, _i, _len;
        switch (typeof input) {
          case "number":
          case "string":
          case "boolean":
            return input;
          case "function":
            return this.errorHandler(new Hydrate.NonPrototypeFunctionError(input, name));
          case "undefined":
            return "__hydrate_undef";
          default:
            if (input === null) {
              return null;
            } else if (Util.isArray(input)) {
              output = [];
              for (i = _i = 0, _len = input.length; _i < _len; i = ++_i) {
                v = input[i];
                output[i] = this.analyze(v, i);
              }
              return output;
            } else {
              if (input.hasOwnProperty("__hydrate_id") && input.__hydrate_id) {
                return "__hydrate_ref_" + input.__hydrate_id;
              } else {
                input.__hydrate_id = Util.d2h(this.counter++);
                this.processed_inputs.push(input);
                output = new Object;
                for (k in input) {
                  v = input[k];
                  if (input.hasOwnProperty(k) && typeof v !== "function") {
                    output[k] = this.analyze(v, k);
                  }
                }
                cons = Util.functionName(input.constructor);
                if (cons === "" && !input.hasOwnProperty("constructor_name")) {
                  cons = input.constructor_name;
                }
                if (!(cons != null)) {
                  this.errorHandler(new Hydrate.AnonymousConstructorError(input));
                }
                if (cons !== "Object") {
                  output.__hydrate_cons = cons;
                }
                if (input.hasOwnProperty("version")) {
                  this.errorHandler(new Hydrate.VersionInstancePropertyError(input));
                }
                if (input.version != null) {
                  output.version = input.version;
                }
                return output;
              }
            }
        }
      };

      Hydrate.prototype.setErrorHandler = function(errorHandler) {
        this.errorHandler = errorHandler;
      };

      Hydrate._refMatcher = /__hydrate_ref_(.*)/;

      Hydrate.prototype.parse = function(input) {
        var l, o, obj, obj_key, ref_id, reference, _i, _len, _ref;
        this.identified_objects = [];
        this.references_to_resolve = [];
        o = JSON.parse(input);
        o = this.fixTree(o);
        if (Util.isArray(o) || ((o != null) && typeof o === "object")) {
          l = o.length;
          if (o != null) {
            _ref = this.references_to_resolve;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              reference = _ref[_i];
              obj = reference[0], obj_key = reference[1], ref_id = reference[2];
              obj[obj_key] = this.identified_objects[ref_id];
            }
            this.clean(o);
          }
        }
        return o;
      };

      Hydrate.prototype.fixTree = function(obj) {
        var k, k2, m, proto, t, tmp, v, v2, _i, _len;
        if (Util.isArray(obj)) {
          for (k = _i = 0, _len = obj.length; _i < _len; k = ++_i) {
            v = obj[k];
            v = this.fixTree(v);
            if (v === "__hydrate_undef") {
              obj[k] = void 0;
            } else if (typeof v === "string" && (m = v.match(Hydrate._refMatcher))) {
              k2 = Util.h2d(m[1]);
              this.references_to_resolve.push([obj, k, k2]);
            } else {
              obj[k] = v;
            }
          }
        } else if (obj === "__hydrate_undef") {
          obj = void 0;
        } else if ((obj != null) && typeof obj === "object") {
          if (obj && (obj.__hydrate_cons != null)) {
            proto = this.resolvePrototype(obj.__hydrate_cons);
            if (proto != null) {
              if (Util.supportsProto) {
                obj.__proto__ = proto;
              } else {
                tmp = (function() {});
                tmp.prototype = proto;
                t = new tmp;
                for (k in obj) {
                  v = obj[k];
                  if (obj.hasOwnProperty(k)) {
                    t[k] = v;
                  }
                }
                obj = t;
              }
            } else {
              this.errorHandler(new Hydrate.PrototypeNotFoundError(obj, obj.__hydrate_cons));
            }
          }
          for (k in obj) {
            v = obj[k];
            if (obj.hasOwnProperty(k)) {
              v = this.fixTree(v);
              if (k === "__hydrate_id") {
                v2 = Util.h2d(v);
                this.identified_objects[v2] = obj;
              } else if (v === "__hydrate_undef") {
                obj[k] = void 0;
              } else if (typeof v === "string" && (m = v.match(Hydrate._refMatcher))) {
                k2 = Util.h2d(m[1]);
                this.references_to_resolve.push([obj, k, k2]);
              } else {
                obj[k] = v;
              }
            }
          }
        }
        return obj;
      };

      Hydrate.prototype.resolvePrototype = function(cons_id) {
        if (!(this.resolver != null)) {
          throw new Error("No Hydrate resolver found -- you should specify one in the Hydrate constructor!");
        }
        return this.resolver.resolve(cons_id);
      };

      Hydrate.prototype.clean = function(o, cleaned) {
        var i, k, migrations, num, v, _i, _j, _len, _ref, _ref1;
        if (cleaned == null) {
          cleaned = [];
        }
        if (o === null || typeof o !== "object") {
          return true;
        }
        if (!Util.isArray(o) && cleaned.indexOf(o) > -1) {
          return true;
        }
        migrations = this.migrations[o.__hydrate_cons];
        if ((o.version != null) && (migrations != null) && o.version < migrations.length) {
          for (num = _i = _ref = o.version, _ref1 = migrations.length - 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; num = _ref <= _ref1 ? ++_i : --_i) {
            migrations[num].call(o);
          }
          delete o.version;
        }
        cleaned.push(o);
        if (Util.isArray(o)) {
          for (_j = 0, _len = o.length; _j < _len; _j++) {
            i = o[_j];
            this.clean(i, cleaned);
          }
        } else {
          for (k in o) {
            v = o[k];
            if (k === "__hydrate_id" || k === "__hydrate_cons") {
              delete o[k];
            } else {
              this.clean(v, cleaned);
            }
          }
        }
        return true;
      };

      Hydrate.prototype.migration = function(klass, index, callback) {
        var all_versions;
        switch (typeof klass) {
          case "function":
            klass = klass.name;
            if (klass === "") {
              this.errorHandler(new Hydrate.AnonymousConstructorError(klass));
            }
            break;
          case "string":
            null;
            break;
          default:
            throw new Error("invalid class passed in; pass a function or a string");
        }
        all_versions = this.migrations[klass];
        if (!(all_versions != null)) {
          all_versions = this.migrations[klass] = [];
        }
        all_versions[index - 1] = callback;
        return true;
      };

      return Hydrate;

    })();
    Resolver = (function() {

      function Resolver() {}

      Resolver.prototype.resolve = function(cons_id) {
        throw new Error("abstract");
      };

      return Resolver;

    })();
    ContextResolver = (function(_super) {

      __extends(ContextResolver, _super);

      function ContextResolver(context) {
        this.context = context;
      }

      ContextResolver.prototype.resolve = function(cons_id) {
        var v;
        v = this.context[cons_id];
        if (v != null) {
          return v.prototype;
        } else {
          return null;
        }
      };

      return ContextResolver;

    })(Resolver);
    MultiResolver = (function(_super) {

      __extends(MultiResolver, _super);

      function MultiResolver(resolvers) {
        this.resolvers = resolvers != null ? resolvers : [];
      }

      MultiResolver.prototype.resolve = function(cons_id) {
        var proto, res, _i, _len, _ref;
        _ref = this.resolvers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          res = _ref[_i];
          proto = res.resolve(cons_id);
          if (proto != null) {
            return proto;
          }
        }
        return null;
      };

      return MultiResolver;

    })(Resolver);
    Hydrate.Util = Util;
    Hydrate.Resolver = Resolver;
    Hydrate.ContextResolver = ContextResolver;
    Hydrate.MultiResolver = MultiResolver;
    return Hydrate;
  });

}).call(this);
